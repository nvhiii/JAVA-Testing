/*
Instance method - needs an object of class to be created before getting called
                + need to create object for this, thus often has no args

Static methods - can just be called without creation of object
                + cannot create object for this method type !!!
                + usually has args!! (doesn't always have to have args)
                + also has the keyword STATIC

Static variables - are often shared by the entire class, and are initialized in value

Instance variables - tied to specific instance of class, not shared with objects in same class

primitive types - are literal values

reference types - are references to objects, etc.

Instance data fields - often are just data type followed by var = value !!

Public modifiers, private modifiers, protected modifiers & Packages

Packages - are called using
           [ package "PackageName"; ]

           If class is defined w/o package stmnt, it is in default package

Public modifiers - Allows for access of member from inside and outside pkg

Private modifiers - Allows for access of data fields in own class

Protected modifiers - Allows for access of member in its own package

If you want users to be prohibited from creating in a certain class,
make the constructor private! (usually should be public)

Data Field Encapsulation - to prevent direct modifications of data fields,
declare data fields private using the private modifier!!

Often, you need to retrieve and modify data fields, this is accomplished
with private by using a getter method.

e.g.
    public returnType getPropertyName(); // accessor

    public boolean isPropertyName(); // e.g. of a boolean accessor

setter e.g.
    public void setPropertyName(dataType propertyValue)


Array of Objects

Syntax:
    Circle[] circleArray = new Circle[10];

    // this stmnt declares and creates an array of 10 circle objects
   to initialize, you can use a for loop

   for (int i = 0; i < circleArray.length; i++) {
    circleArray[i] = new Circle();

*when array of objects created using new operator, each element in array is
ref variable with default value null

**printf is print formatting**
    - can check formatting documentation whilst using printf, useful for formatting

Immutable Objects & Classes
    - occassionally it is desirable to create an object whose contents cannot be changed once object is created
        - "immutable" class & object
    - if class is immutable, all data fields must be private w/ no public setter methods

Variable Scope

This key-word to reference data fields

Thinking in Objects

Class Relationships

Association
    - relations implemented using data fields
    **different classes access another class which they share in common**
    -

Aggregation
    - may exist between objects of same class
    - represents ownership relationship between two objects'
    - models a "has-a" relationship

    - the OWNER object is called an aggregating object and its class is called an aggregating class
    - the SUBJECT object is called an aggregated object, and its class is called an aggregated class
    - this is called composition if the existence of the aggregated object is dependent on the aggregating object
    - it implies one object exclusive ownership
    - a filled black diamond attached to aggregating class represents composition

    - an unfilled white diamond attached to aggregating class represents aggregation


    e.g.
    public class Person {

    private Person supervisor;

    }


    }

Designing Class for Courses - 10/2

Designing Class for Stacks - 10/3 --> 10/4

public keyword - declare's member's access as public

static keyword - used to share same var or method of given class (mostly for memory management)

void keyword - denotes that a method does not have a return type

API - application programming interface (offering service to other software)

Processing Primitive Data Type Values as Objects

    - primitive data type values are not objects
    (wrapping data type into object)
    e.g.
        - int to Integer
        - double to Double
        - char to Character
Using these wrapper classes, you can process primitive data types as objects
    e.g. of Wrapper classes in java.lang package
    - Boolean
    - Character
    - Double
    - Float
    - Byte
    - Short
    - Integer
    - Long

Each of these numeric wrapper classes contain a method to "convert" objects into primitive types"
    e.g.
    doubleValue(), floatValue(), intValue(), longValue(), shortValue(), byteValue()

Can construct wrapper object from primitive data type or from string
    e.g.
    new Double(5.0) = new Double("5.0")

Instances of wrapper classes are immutable, meaning once the objects are created, their values cannot be changed

Each numeric wrapper class has MAX_VALUE(Byte, Short, Integer, and Long)
Each numeric wrapper class has MIN_VALUE
    **MIN_VALUE shows minimum from byte, short, int, and long
    **MIN_value shows minimum POSITIVE float and double

Each numeric wrapper class contains doubleValue(), floatValue(), intValue(), longValue(), and shortValue()
    - returns double, float, int, long, or short

    Syntax:

    new Double(12.4).intValue() // returns 12
    new Integer(12).doubleValue() // returns 12.0

Numeric wrapper class also contains compareTo method which returns 1, 0, or -1
Based off if the number is greater than, equal to, or less than the other number

e.g.
new Double(12.4).compareTo(new Double(12.3)); // returns 1


static valueOf methods
    - this method creates a new object initialized to the value represented by the specified string

    e.g.
    Double doubleObject = Double.valueOf(12.4);

static parsing methods
    - Each numeric wrapper class hass two overloaded parsing methods to parse a numeric string
      into an appropriate numeric value based on 10 or any radix (2 for binary, 8 for octal, 16 for hexadecimal)

    e.g.
    public static parseInt (String s)
    public static int parseInt (String s, int radix)

    Integer.parseInt("11, 2"); // returns 3 because of binary

    ** You can also convert a decimal number into hex number using format method

    e.g.

    String.format("%x", 26); // returns 1A

10.8) Automatic Conversion Between Primitive Types and Wrapper Class Types

- converting a primitive value to a wrapper object is called boxing
- the reverse process is called unboxing

e.g.:
    Integer intObject = new Integer(2); (is equal to)
    Integer intObject = 2;

    **this is due to autoboxing**

    int i = 1; (is equal to)
    Integer i = new Integer(1);

    **this is due to autounboxing


10.9) The BigInteger and BigDecimal Classes

- can be used to represent integers or decimal numbers of any size and precision
**contained in the java.math package is immutable

- BigInteger can represent an integer of any size
- Also can create instances of these both using BigInteger(String) or BigDecimal(String)

- used with the methods of add, subtract, multiply, divide, and remainder

- divide method may throw ArithmeticException if result cannot be terminated
** use overloaded **
    divide(BigDecimal d, int scale, int roundingMode)

    e.g.:
    divide(b, 20, BigDecimal.ROUND_UP)

relevant code:
LargeFactorial.java

10.10) The String Class

- String objects are immutable, it cannot be changed once it is created
    methods:
        - charAt(index)
        - length()
        - substring
        - indexOf
        - lastIndexOf
        - equals
        - compareTo
        - trim()
        - toLowerCase()
        - toUpperCase()

Constructing a String

syntax:
    String newString = new String(stringLiteral);

**You can also create a string from array of characters**

e.g.
    char[] charArray = {'G', 'o', 'o', 'd', ' ', 'D', 'a', 'y'};
    String message = new String(charArray);

Immutable Strings and Interned Strings

- because strings are immutable, JVM uses unique instance of string literals to improve efficiency and save memory (interned string)
- therefore, even if two string objects have same contents, they are not necessarily equal

e.g.
    String s1 = "Welcome to Java";
    String s2 = new String("Welcome to Java");
    String s3 = "Welcome to Java";

    s1 != s2
    but,
    s1 == s3

Replacing and Splitting Strings
    Methods:
    - replace
        syntax:
        "Welcome".replace("e", "AB") returns a new string, WABlcomAB.

    - replaceFirst
        syntax:
        "Welcome".replaceFirst("e", "AB") returns a new string, WABlcome.

    - replaceAll
        syntax:
        String s = "a+b$#c".replaceAll("[$+#]", "NNN");
        System.out.println(s);

        regex[$+#] specifies chars to replace: $, +, and #
        thus this prints out aNNNbNNNNNNc

    ** these all return a new string derived from original string without altering the og string

    - split
    ** used to extract tokens from string with specified delimiter(s)
        syntax:
        String[] tokens = "Java#HTML#Perl".split("#");

        for (int i = 0; i < tokens.length; i++)
            System.out.print(tokens[i] + " ");

        displays Java HTML Perl

Matching, Replacing, and Splitting by Patterns

- often there will be a need to write code that validates user input
    ** a regular expression, or REGEX is a string that describes a pattern for matching a set of strings

    Method(s):
    - matches
    ** matches fixed strings and set of strings that follow a pattern

        syntax:
        "Java".equals("Java");

        "Java is powerful".matches("Java.*")

        ** Java.* is a regex which describes a string pattern that begins with Java followed by any zero of more characters
        or

        "440–02–4534".matches("\\d{3}–\\d{2}–\\d{4}")

        ** \\d represents a single digit, \\d{#} represents # digits
        or

        String[] tokens = "Java,C?C#,C++".split("[.,:;?]");

        for (int i = 0; i < tokens.length; i++)
            System.out.println(tokens[i]);

        ** this [.,:;?] specifies a pattern that matches any of the char inside the square brackets, and thus splits the string

Conversion between Strings and Arrays

- strings can be converted into an array and vice versa

- for strings to array of char, use toCharArray method

    syntax:
    char[] chars = "Java".toCharArray();

    char[0] is J
    char[1] is a
    char[2] is v
    char[3] is a

- can also use getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
    ** to copy substring of string from index srcBegin to index srcEnd-1 into array dst starting from index dstBegin



 */
