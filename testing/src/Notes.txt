/*
Key:
- Chapters end with ")" character
- Chapter sections end with ":" character
- Chapter subsections end with "-" character
- Relevant code provided at end of each section / subsection

https://media.pearsoncmg.com/ph/esm/ecs_liang_ijp_12/cw/content/ExampleByChapters.html

^^ all liang src tb code is in the link above, I just collected them into this src file

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Chapter 9) Objects and Classes

9.1: Introduction

9.2: Defining Classes for Objects

9.3: Defining Classes and Creating Objects

9.4: Constructing Objects Using Constructors

9.5: Accessing Objects via Reference Variables

Instance method - needs an object of class to be created before getting called
                + need to create object for this, thus often has no args

Static methods - can just be called without creation of object
                + cannot create object for this method type !!!
                + usually has args!! (doesn't always have to have args)
                + also has the keyword STATIC

9.5.4 - Differences between Variables of Primitive Types and Reference Types

    primitive types - are literal values

    reference types - are references to objects, etc.

9.6: Using Classes from the Java Library

9.7: Static Variables, Constants, and Methods

Static variables - are often shared by the entire class, and are initialized in value

Instance variables - tied to specific instance of class, not shared with objects in same class

Instance data fields - often are just data type followed by var = value !!

Public modifiers, private modifiers, protected modifiers & Packages

Packages - are called using
           [ package "PackageName"; ]

           If class is defined w/o package stmnt, it is in default package

9.8: Visibility Modifiers

Public modifiers - Allows for access of member from inside and outside pkg

Private modifiers - Allows for access of data fields in own class

Protected modifiers - Allows for access of member in its own package

9.9: Data Field Encapsulation

If you want users to be prohibited from creating in a certain class,
make the constructor private! (usually should be public)

Data Field Encapsulation - to prevent direct modifications of data fields,
declare data fields private using the private modifier!!

Often, you need to retrieve and modify data fields, this is accomplished
with private by using a getter method.

e.g.
    public returnType getPropertyName(); // accessor

    public boolean isPropertyName(); // e.g. of a boolean accessor

setter e.g.
    public void setPropertyName(dataType propertyValue)

9.10: Passing Objects to Methods


9.11: Array of Objects

Syntax:
    Circle[] circleArray = new Circle[10];

    // this stmnt declares and creates an array of 10 circle objects
   to initialize, you can use a for loop

   for (int i = 0; i < circleArray.length; i++) {
    circleArray[i] = new Circle();

*when array of objects created using new operator, each element in array is
ref variable with default value null

**printf is print formatting**
    - can check formatting documentation whilst using printf, useful for formatting

9.12: Immutable Objects & Classes
    - occassionally it is desirable to create an object whose contents cannot be changed once object is created
        - "immutable" class & object
    - if class is immutable, all data fields must be private w/ no public setter methods

9.13: Variable Scope

9.14: This key-word to reference data fields

9.14.1 - Using this to Reference Data Fields

9.14.2 - Using this to Invoke a Constructor

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Chapter 10) Object-Oriented Thinking

10.1: Introduction

10.2: Class Abstraction and Encapsulation

10.3: Thinking in Objects

10.4: Class Relationships

Association
    - relations implemented using data fields
    **different classes access another class which they share in common**
    -

Aggregation
    - may exist between objects of same class
    - represents ownership relationship between two objects'
    - models a "has-a" relationship

    - the OWNER object is called an aggregating object and its class is called an aggregating class
    - the SUBJECT object is called an aggregated object, and its class is called an aggregated class
    - this is called composition if the existence of the aggregated object is dependent on the aggregating object
    - it implies one object exclusive ownership
    - a filled black diamond attached to aggregating class represents composition

    - an unfilled white diamond attached to aggregating class represents aggregation


    e.g.
    public class Person {

    private Person supervisor;

    }


    }

10.5: Case Study: Designing the Course Class

10.6: Case Study: Designing Class for Stacks

Relevant code:

TestStackOfIntegers.java
StackOfIntegers.java

public keyword - declare's member's access as public

static keyword - used to share same var or method of given class (mostly for memory management)

void keyword - denotes that a method does not have a return type

API - application programming interface (offering service to other software)

10.7: Processing Primitive Data Type Values as Objects

    - primitive data type values are not objects
    (wrapping data type into object)
    e.g.
        - int to Integer
        - double to Double
        - char to Character
Using these wrapper classes, you can process primitive data types as objects
    e.g. of Wrapper classes in java.lang package
    - Boolean
    - Character
    - Double
    - Float
    - Byte
    - Short
    - Integer
    - Long

Each of these numeric wrapper classes contain a method to "convert" objects into primitive types"
    e.g.
    doubleValue(), floatValue(), intValue(), longValue(), shortValue(), byteValue()

Can construct wrapper object from primitive data type or from string
    e.g.
    new Double(5.0) = new Double("5.0")

Instances of wrapper classes are immutable, meaning once the objects are created, their values cannot be changed

Each numeric wrapper class has MAX_VALUE(Byte, Short, Integer, and Long)
Each numeric wrapper class has MIN_VALUE
    **MIN_VALUE shows minimum from byte, short, int, and long
    **MIN_value shows minimum POSITIVE float and double

Each numeric wrapper class contains doubleValue(), floatValue(), intValue(), longValue(), and shortValue()
    - returns double, float, int, long, or short

    Syntax:

    new Double(12.4).intValue() // returns 12
    new Integer(12).doubleValue() // returns 12.0

Numeric wrapper class also contains compareTo method which returns 1, 0, or -1
Based off if the number is greater than, equal to, or less than the other number

e.g.
new Double(12.4).compareTo(new Double(12.3)); // returns 1


static valueOf methods
    - this method creates a new object initialized to the value represented by the specified string

    e.g.
    Double doubleObject = Double.valueOf(12.4);

static parsing methods
    - Each numeric wrapper class hass two overloaded parsing methods to parse a numeric string
      into an appropriate numeric value based on 10 or any radix (2 for binary, 8 for octal, 16 for hexadecimal)

    e.g.
    public static parseInt (String s)
    public static int parseInt (String s, int radix)

    Integer.parseInt("11, 2"); // returns 3 because of binary

    ** You can also convert a decimal number into hex number using format method

    e.g.

    String.format("%x", 26); // returns 1A

10.8: Automatic Conversion Between Primitive Types and Wrapper Class Types

- converting a primitive value to a wrapper object is called boxing
- the reverse process is called unboxing

e.g.:
    Integer intObject = new Integer(2); (is equal to)
    Integer intObject = 2;

    **this is due to autoboxing**

    int i = 1; (is equal to)
    Integer i = new Integer(1);

    **this is due to autounboxing


10.9: The BigInteger and BigDecimal Classes

- can be used to represent integers or decimal numbers of any size and precision
**contained in the java.math package is immutable

- BigInteger can represent an integer of any size
- Also can create instances of these both using BigInteger(String) or BigDecimal(String)

- used with the methods of add, subtract, multiply, divide, and remainder

- divide method may throw ArithmeticException if result cannot be terminated
** use overloaded **
    divide(BigDecimal d, int scale, int roundingMode)

    e.g.:
    divide(b, 20, BigDecimal.ROUND_UP)

Relevant code:
LargeFactorial.java

10.10: The String Class

- String objects are immutable, it cannot be changed once it is created
    Method(s):
        - charAt(index)
        - length()
        - substring
        - indexOf
        - lastIndexOf
        - equals
        - compareTo
        - trim()
        - toLowerCase()
        - toUpperCase()

10.10.1 - Constructing a String

syntax:
    String newString = new String(stringLiteral);

**You can also create a string from array of characters**

e.g.
    char[] charArray = {'G', 'o', 'o', 'd', ' ', 'D', 'a', 'y'};
    String message = new String(charArray);

10.10.2 - Immutable Strings and Interned Strings

- because strings are immutable, JVM uses unique instance of string literals to improve efficiency and save memory (interned string)
- therefore, even if two string objects have same contents, they are not necessarily equal

e.g.
    String s1 = "Welcome to Java";
    String s2 = new String("Welcome to Java");
    String s3 = "Welcome to Java";

    s1 != s2
    but,
    s1 == s3

10.10.3 - Replacing and Splitting Strings
    Methods:
    - replace
        syntax:
        "Welcome".replace("e", "AB") returns a new string, WABlcomAB.

    - replaceFirst
        syntax:
        "Welcome".replaceFirst("e", "AB") returns a new string, WABlcome.

    - replaceAll
        syntax:
        String s = "a+b$#c".replaceAll("[$+#]", "NNN");
        System.out.println(s);

        regex[$+#] specifies chars to replace: $, +, and #
        thus this prints out aNNNbNNNNNNc

    ** these all return a new string derived from original string without altering the og string

    - split
    ** used to extract tokens from string with specified delimiter(s)
        syntax:
        String[] tokens = "Java#HTML#Perl".split("#");

        for (int i = 0; i < tokens.length; i++)
            System.out.print(tokens[i] + " ");

        displays Java HTML Perl because # is the delimiter and the for loop iterates the array tokens, adding a space in between each word

10.10.4 - Matching, Replacing, and Splitting by Patterns

- often there will be a need to write code that validates user input
    ** a regular expression, or REGEX is a string that describes a pattern for matching a set of strings

    Method(s):
    - matches
    ** matches fixed strings and set of strings that follow a pattern

        syntax:
        "Java".equals("Java");

        "Java is powerful".matches("Java.*")

        ** Java.* is a regex which describes a string pattern that begins with Java followed by any zero of more characters
        or

        "440–02–4534".matches("\\d{3}–\\d{2}–\\d{4}")

        ** \\d represents a single digit, \\d{#} represents # digits
        or

        String[] tokens = "Java,C?C#,C++".split("[.,:;?]");

        for (int i = 0; i < tokens.length; i++)
            System.out.println(tokens[i]);

        ** this [.,:;?] specifies a pattern that matches any of the char inside the square brackets, and thus splits the string

10.10.5 - Conversion between Strings and Arrays

- strings can be converted into an array and vice versa

- for strings to array of char, use toCharArray method

    syntax:
    char[] chars = "Java".toCharArray();

    char[0] is J
    char[1] is a
    char[2] is v
    char[3] is a

- can also use getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
    ** to copy substring of string from index srcBegin to index srcEnd-1 into array dst starting from index dstBegin
    ** gets char from another string from firstNum (inclusive) to nextNum specified, specified array, then adds into specified index

10.10.6 - Converting Characters and Numeric Values to Strings

- convert numbers into strings using overloaded static valueOf method

    syntax:
    String.valueOf(data);

10.10.7 - Formatting Strings

- String class contains format method to return formatted string

    syntax:
    String.format(format, item1, item2, ..., itemn);

    Reference to formatting:
    https://stackabuse.com/how-to-format-a-string-in-java-with-examples/

    Format specifiers:
    %c - Character
    %d - Decimal number (base 10)
    %e - Exponential floating-point number
    %f - Floating-point number
    %i - Integer (base 10)
    %o - Octal number (base 8)
    %s - String
    %u - Unsigned decimal (integer) number
    %x - Hexadecimal number (base 16)
    %t - Date/time
    %n - Newline

    Formatting cmds:
    \b - Insert backspace
    \f - Next line's first character starts to the right of current line's last character
    \n - Insert newline
    \r - Insert carriage return
    \t - Insert tab
    \\ - Insert backslash
    %% - Insert percentage sign

10.11: The StringBuilder and StringBuffer Classes

- these are mutable and can be used where a string is used
- can add, insert, or append new contents into their objects

- methods for modifying the buffer in StringBuffer are synchronized
    ** only one task allowed to execute the methods

- use StringBuffer if class might be accessed by multiple taks (concurrent programming)

- use StringBuilder if class is accessed by single task (no synchronization)
    ** Has three constructors and more than 30 methods to manage the builder and modify the strings in the builder

    syntax:
    StringBuilder(); // empty string builder constructed with capacity of 16

    StringBuilder(capacity: int); // string builder constructed with capacity of specified int

    StringBuilder(s: String);   // string builder constructed with specified string

10.11.1 - Modifying Strings in the StringBuilder

- there are many methods in the stringbuilder class to append, insert, delete, and replace a specified position in string builder

    Method(s)
    +append(data: char[]): StringBuilder    // appends a char array into string builder

    +append(data: char[], oset: int, len: int):
    StringBuilder                           // appends a subarray in data into this string builder

    +append(v: aPrimitiveType): StringBuilder   // appends a primitive-type value as a string to this builder

    +append(s: String): StringBuilder           // appends a string to this string builder

    +delete(startIndex: int, endIndex: int):
    StringBuilder                               // Deletes characters from startIndex to endIndex-1

    +deleteCharAt(index: int): StringBuilder    // deletes a character at a specified index

    +insert(index: int, data: char[], oset: int,
    len: int): StringBuilder                    // inserts a subarray of the data in the array into the builder at the specified index

    +insert(oset: int, data: char[]):
    StringBuilder                               // Inserts data into this builder at the position offset.

    +insert(oset: int, b: aPrimitiveType):
    StringBuilder                               // Inserts a value converted to a string into this builder.

    +insert(oset: int, s: String): StringBuilder   // Inserts a string into this builder at the position offset

    +replace(startIndex: int, endIndex: int, s:
    String): StringBuilder                      // Replaces the characters in this builder from startIndex
                                                   to endIndex – 1 with the specied string

    +reverse(): StringBuilder                   // Reverses the characters in the builder

    +setCharAt(index: int, ch: char): void      // Sets a new character at the specied index in this
                                                   builder

    ** if a string does not need to be changed, use String not StringBuilder **

10.11.2 - The toString, capacity, length, setLength, and charAt Methods

- There are also methods to manipulate string builders and obtain their properties

    Method(s)
    +toString(): String // Returns a string object from the string builder.

    +capacity(): int    // Returns the capacity of this string builder.

    +charAt(index: int): char   // Returns the character at the specied index.

    +length(): int  // Returns the number of characters in this builder.

    +setLength(newLength: int): void    // Sets a new length in this builder.

    +substring(startIndex: int): String // Returns a substring starting at startIndex.

    +substring(startIndex: int, endIndex: int): // Returns a substring from startIndex to endIndex – 1.
        String

    +trimToSize(): void // Reduces the storage size used for the string builder.

10.11.3 - Case Study: Ignoring Nonalphanumeric Characters When Checking Palindromes

Relevant code:
PalindromeIgnoreNonAlphanumeric.java // gotta do this in the src

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Chapter 11) Inheritance and Polymorhpism

11.1: Introduction

Inheritance - the ability to define new classes from existing classes
    ** powerful feature for reusing software

11.2: Superclasses and Subclasses

- Inheritance enables the definition of a general class (superclass) and extend to a subclass

subclass - a class extended from another class
    ** child class / extended class / derived class
    ** inherts all accessible data fields and methods from superclass and may add data fields and methods

superclass - class that another class that extends from
    ** parent class / base class

subtype - type defined by a subclass

is-a relationship - subclass "is-a" part of superclass

** once again, private data fields in a class cannot be accessed from another class
** therefore, subclasses cannot access private data fields in their corresponding superclass

Key Takeaways Regarding Inheritance:

- Subclass is NOT a subset of superclass, instead it has more info and methods than the superclass

- Private data fields in superclass not accessible outside the class, therefore cannot be used directly in subclass
    ** they can be accessed/modified through public accessors/mutators ONLY IF defined in the SUPERCLASS

- Not all is-a relationships should be modeled using inheritance b/c not all subclasses has a is-a relationship w/ others under the same superclass

- Don't extend a class unless the classes have an "is-a" relationship

- Java does not have multiple inheritance, thus you CANNOT derive subclass from several classes
    ** This is called single inheritance, where a subclass can ONLY have one parent

11.3: Using the super Keyword

- super refers to the superclass (parent) & invokes superclasses methods and constructors

- subclass inherits accessible data fields and methods

    ** this reference can be used to call a superclass constructor or a superclass method

Relevant code:
SimpleGeometricObject.java
CircleFromSimpleGeometricObject.java
RectangleFromSimpleGeometricObject.java
TestCircleRectangle.java

11.3.1 - Calling Superclass Constructors:

- constructors of a superclass are not inherited by a subclass, but they can be invoked using super keyword

    e.g.

    super() or super(args);

    public Circle(double radius, String color, boolean filled) {
        super(color, filled); // this refers to the superclass geometricObject's args constructor
        this.radius = radius;
    }

11.3.2 - Constructor Chaining

- constructor may invoke overloaded constructor(multiple same name constructors, diff param) or superclass constructor

- constructing an instance of a class invokes constructors of all superclasses along inheritance chain until the last constructor along the hierarchy is called
    ** constructor chaining^^

    simple example of constructor chaining:

    1 public class Faculty extends Employee {
    2   public static void main(String[] args) {
    3       new Faculty();
    4   }
    5
    6   public Faculty() {
    7       System.out.println("(4) Performs Faculty's tasks");
    8   }
    9  }
    10
    11  class Employee extends Person {
    12      public Employee() {
    13          this("(2) Invoke Employee's overloaded constructor");
    14          System.out.println("(3) Performs Employee's tasks ");
    15  }
    16
    17      public Employee(String s) {
    18          System.out.println(s);
    19      }
    20  }
    21
    22  class Person {
    23      public Person() {
    24          System.out.println("(1) Performs Person's tasks");
    25      }
    26   }

** if a class is designed to be extended, provide a no-arg constructor to avoid errors

11.3.3 - Calling Superclass Methods

- keyword super can be used to reference method other than constructor in superclass

    syntax:

    super.method(args);


11.4: Overriding Methods

- to override a method, the method must be defined in the subclass using same signature as its superclass

- Overriding method must have same signature as overridden method and same/compatible return type
    ** signature is part of method declaration, it is the method name + params

- Instance method can be overridden only if it is accessible
    ** private method cannot be overridden

- Static method can also be inherited but cannot be overridden

// This topic is sort-of confusing, will revisit this in more depth later**

11.5: Overriding vs. Overloading

- overriding is to provide a new implementation for a method in the subclass
    ** if there is a subclass of a superclass with same method signature as the method in the superclass, the subclass method would override the method in the superclass

- overloading is to define multiple methods w/ the same name but diff signatures
    ** same method name except for params, therefore is overloading

∵
- overridden methods are in diff classes by inheritance (super / subclass)

- overloaded methods can be either in same class of diff classes by inheritance

- overridden methods have same signature

- overloaded methods have same name but diff param

    syntax:

    public class Circle extends GeometricObject {

        @Override
        public String toString0 {
            return super.toString() + "\n" + "radius is " + radius;
        }
    }

    ** the @Override is called override annotation, which is oft3en placed before the overriding method
        Using this annotation, mistakes can be avoided

11.6: The Object Class and Its toString() Method

- Every class in Java is descended from the java.lang.Object class

    syntax:
    public String toString()

- invoking toString() on object returns a string that describes the object

Common Issue with toString() Method:

    e.g.
    Loan loan = new Loan();
    System.out.println(loan.toString());

    // this displays Loan@15037e5 (binary bs)

** To avoid this issue, override the toString method in the Object class

11.7: Polymorphism

- means that a var of supertype can refer to subtype object

There are 3 Pillars of OOP (Object Oriented Programming)

1. Data hiding in ENCAPSULATION

2. Inheritance -  your class and other class, your class gets something from the other class (child class gets from the parent class etc.)
    ** inherits attributes and methods from another class
    ** Each class has exactly one parent, something exclusive to JAVA
    ** this is a "IS A" relationship unike composition & aggregation, which are "HAS A" relationships
    ** instance variable - created when object created

3. Polymorphism
    ** an object of a subclass can be used wherever its superclass object is used
    ** Uses methods attained from inheritance to perform other tasks


Relevant code:
PolymorphismDemo.java // review this code

** This topic is sort-of confusing as well, check back later

11.8: Dynamic Binding:

- a method can be implemented in several classes in inheritance chain. JVM decides which is invoked

- when compiler cannot compile call/binding at compile time

Which method: overloaded / overridden method is invoked first?

- a variable must be declared a type

declared type - type that declares a var is called vars declared type
    
    type - variables and expressions all have this; e.g. int, double, etc.

    ** var of reference type can hold null or reference to instance of declared type
        ** insance may be created using the constructor of declared type or subtype


actual type - the actual class for object referenced by var

- the method that invokes an object is determined by the object's actual type // known as dynamic binding

Relevant code:
DynamicBindingDemo.java

11.9: Casting Objects and the instanceof operator

- object refernece can be typecast into another object reference

    e.g.

    m(new Student()) (is equals to)

    Object o = new Student();
    m(o);

    // implicit Casting ^^


    Student b = (Student)O

    // explicit casting ^^










----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Chapter 12) Exception Handling and Text I/O

12.1: Introduction

- Exceptions are runtime errors
- Exception handling enables a program to deal with runtime errors and continue its normal execution
    e.g.
    https://www.geeksforgeeks.org/types-of-exception-in-java-with-examples/     // these are built in exceptions (There is a hierarchy of exceptions / NOT A LIST // class notes & slides)
    - ArrayIndexOutOfBounds
    - InputMismatchException, etc.


12.2: Exception-handling Overview

- program method should never terminate the program, should be up to user
- Java enables a method to throw an exception that be caught and handled by the caller

    syntax:
    public ...
        if (conditional)
            throw new EXCEPTION("output to caller") // exception is an object thrown (specified exeception is dataType in java API)

    public static void main(String [] args) {

        stmnts...;

        try {
            stmnts / methods...
        } catch (EXCEPTION catchBlockParameter) {   // catch-block header // catch-block param is usually ex
            code to process exception...
            // usually a print statement
        }

        stmnts...
    }

- the execution of a throw stmnt is called throwing an exception
    ** exception is an object created from an exception class
- when an exception is thrown, normal execution is interrupted
- "throw an exception" passes an exception from one place to another
    ** the stmnt to invoke the method is in a "try" block

- the try block contains code that is executed in normal circumstances

- the exception is caught by the catch block

- the catch block is executed to handle the exception

** advanage of using exception handling
    - it enables a method to throw an exception to its caller, enabling the caller to handle the exception

- often, methods called do not know what to do in case of an error
    **this is typically the case for library methods
    ** key benefit is separating the detection of error (in called method) from the handling of error (in calling method)

**runtime exceptions don't have to be declared, thus every other exception must be included after the called method param as well as in method body in the called method**

Relevant code:
Quotient.java
QuotientWithIf.java
QuotientWithMethod.java
QuotientWithException.java

12.3: Exception Types

- the root class for exceptions is java.lang.Throwable

** The class names Error, Exception, and RuntimeException are all exceptions and all of the errors occur at runtime

- you can create own exception classes by extending Eception or a subclass of Exception

- exception classes can be classified into 3 major types:
    1. System errors - thrown by JVM and are represented in the Error class
        ** Error class describes internal system errors
    
    2. Exceptions - represented by Exception class, which describes errors caused by your program and by external circumstances
        ** these errors can be caught and handled by your program

    3. Runtime Exceptions - represented in RuntimeException class - which describes programming errors

** if its possible to rethrow an exception, it throws it to antoher method **
    e.g.

    for example, if the exception is in method1 and another method, method2 calls it and it throws exception right after its param, and if said method2 is called in another method, the exception travels up the stack
        ** must have checked exceptions (the middle method(s) throws exception)

        **All other exceptions other than runtime and errors are checked exceptions, needing try and catch blocks

    stack diagram is a very good way to trace exception rethrows** also in main, the "throw exception" is optional

    runtime exceptions don't have to be declared as usual
        ** runtime exceptions are unchecked exceptions (their subclasses too)

    errors are like runtime exceptions because they are unchecked (their subclasses too)


12.4: More on Exception Handling

- A handler for exception is found through chain of reverse method calls, starting from current method

12.4.1 - Declaring Exceptions

- Often, to declare an exception in a method, you do it in the method header using: throws EXCEPTION after the method params
    ** if there are multiple exceptions to be thrown, go to the next line and do: throws EXCEPTION1, EXCEPTION2, ..., etc. (the exceptions are separated by commas)

12.4.2 - Throwing Exceptions

- program that detects an error which creates an instance of the appropriate exception type

12.4.3 - Catching Exceptions

12.4.4 - Getting Information from Exceptions

- exception object has valuable info about exception

    Method(s)

    from java.lang.Throwable, you can get info regarding the exception using these methods:

    +getMessage(): String   // Returns the message that describes this exception object.

    +toString(): String // Returns the concatenation of three strings: (1) the full name of the exception
                           class; (2) ":" (a colon and a space); and (3) the getMessage() method

    +printStackTrace(): void    // Prints the Throwable object and its call stack trace information on the
                                       console.

    +getStackTrace():
    StackTraceElement[] // Returns an array of stack trace elements representing the stack trace
                               pertaining to this exception object.

Relevant code:

TestException.java

12.4.5 - Example: Declaring, Throwing, and Catching Exceptions

Relevant code:

CircleWithException.java
TestCircleWithException.java


12.5: The finally Clause

12.6: When to Use Exceptions

12.7: Rethrowing Exceptions

12.8: Chained Exceptions

Relevant code:
ChainedExceptionDemo.java

12.9: Defining Custom Exception Classes

Relevant code:
InvalidRadiusException.java
TestCircleWithCustomException.java

12.10: The File Class

    Method(s):


Relevant code:
TestFileClass.java

12.11: File Input and Output

12.11.1 - Writing Data Using PrintWriter

    Method(s):

Relevant code:
WriteData.java

12.11.2 - Closing Resources Automatically Using try-with-resources

Relevant code:
WriteDataWithAutoClose.java

12.11.3 - Reading Data Using Scanner

    Method(s):


Relevant code:
ReadData.java

12.11.4 - How Does Scanner Work?

12.11.5 - Case Study: Replacing Text

Relevant code:
ReplaceText.java

12.12: Reading Data from the Web

Relevant code:
readFileFromURL.java

12.13: Case Study: Web Crawler

Relevant code:
WebCrawler.java


Relevant code:

12.5 - InputMismatchExceptionDemo.java

// must do ch12 reading n stuff 10/28 ** ASSIGNMENTS DUE 11/2 and 11/4 DO ASAP

    


// **add chapter 13 here
 */
