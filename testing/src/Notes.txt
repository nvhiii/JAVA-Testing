/*
Key:
- Chapters end with ")" character
- Chapter sections end with ":" character
- Chapter subsections end with "-" character
- Relevant code provided at end of each section / subsection

Chapter 9) Objects and Classes

9.1: Introduction

9.2: Defining Classes for Objects

9.3: Defining Classes and Creating Objects

9.4: Constructing Objects Using Constructors

9.5: Accessing Objects via Reference Variables

Instance method - needs an object of class to be created before getting called
                + need to create object for this, thus often has no args

Static methods - can just be called without creation of object
                + cannot create object for this method type !!!
                + usually has args!! (doesn't always have to have args)
                + also has the keyword STATIC

9.5.4 - Differences between Variables of Primitive Types and Reference Types

    primitive types - are literal values

    reference types - are references to objects, etc.

9.6: Using Classes from the Java Library

9.7: Static Variables, Constants, and Methods

Static variables - are often shared by the entire class, and are initialized in value

Instance variables - tied to specific instance of class, not shared with objects in same class

Instance data fields - often are just data type followed by var = value !!

Public modifiers, private modifiers, protected modifiers & Packages

Packages - are called using
           [ package "PackageName"; ]

           If class is defined w/o package stmnt, it is in default package

9.8: Visibility Modifiers

Public modifiers - Allows for access of member from inside and outside pkg

Private modifiers - Allows for access of data fields in own class

Protected modifiers - Allows for access of member in its own package

9.9: Data Field Encapsulation

If you want users to be prohibited from creating in a certain class,
make the constructor private! (usually should be public)

Data Field Encapsulation - to prevent direct modifications of data fields,
declare data fields private using the private modifier!!

Often, you need to retrieve and modify data fields, this is accomplished
with private by using a getter method.

e.g.
    public returnType getPropertyName(); // accessor

    public boolean isPropertyName(); // e.g. of a boolean accessor

setter e.g.
    public void setPropertyName(dataType propertyValue)

9.10: Passing Objects to Methods


9.11: Array of Objects

Syntax:
    Circle[] circleArray = new Circle[10];

    // this stmnt declares and creates an array of 10 circle objects
   to initialize, you can use a for loop

   for (int i = 0; i < circleArray.length; i++) {
    circleArray[i] = new Circle();

*when array of objects created using new operator, each element in array is
ref variable with default value null

**printf is print formatting**
    - can check formatting documentation whilst using printf, useful for formatting

9.12: Immutable Objects & Classes
    - occassionally it is desirable to create an object whose contents cannot be changed once object is created
        - "immutable" class & object
    - if class is immutable, all data fields must be private w/ no public setter methods

9.13: Variable Scope

9.14: This key-word to reference data fields

9.14.1 - Using this to Reference Data Fields

9.14.2 - Using this to Invoke a Constructor

Chapter 10) Object-Oriented Thinking

10.1: Introduction

10.2: Class Abstraction and Encapsulation

10.3: Thinking in Objects

10.4: Class Relationships

Association
    - relations implemented using data fields
    **different classes access another class which they share in common**
    -

Aggregation
    - may exist between objects of same class
    - represents ownership relationship between two objects'
    - models a "has-a" relationship

    - the OWNER object is called an aggregating object and its class is called an aggregating class
    - the SUBJECT object is called an aggregated object, and its class is called an aggregated class
    - this is called composition if the existence of the aggregated object is dependent on the aggregating object
    - it implies one object exclusive ownership
    - a filled black diamond attached to aggregating class represents composition

    - an unfilled white diamond attached to aggregating class represents aggregation


    e.g.
    public class Person {

    private Person supervisor;

    }


    }

10.5: Case Study: Designing the Course Class

10.6: Case Study: Designing Class for Stacks

Relevant code:

TestStackOfIntegers.java
StackOfIntegers.java

public keyword - declare's member's access as public

static keyword - used to share same var or method of given class (mostly for memory management)

void keyword - denotes that a method does not have a return type

API - application programming interface (offering service to other software)

10.7: Processing Primitive Data Type Values as Objects

    - primitive data type values are not objects
    (wrapping data type into object)
    e.g.
        - int to Integer
        - double to Double
        - char to Character
Using these wrapper classes, you can process primitive data types as objects
    e.g. of Wrapper classes in java.lang package
    - Boolean
    - Character
    - Double
    - Float
    - Byte
    - Short
    - Integer
    - Long

Each of these numeric wrapper classes contain a method to "convert" objects into primitive types"
    e.g.
    doubleValue(), floatValue(), intValue(), longValue(), shortValue(), byteValue()

Can construct wrapper object from primitive data type or from string
    e.g.
    new Double(5.0) = new Double("5.0")

Instances of wrapper classes are immutable, meaning once the objects are created, their values cannot be changed

Each numeric wrapper class has MAX_VALUE(Byte, Short, Integer, and Long)
Each numeric wrapper class has MIN_VALUE
    **MIN_VALUE shows minimum from byte, short, int, and long
    **MIN_value shows minimum POSITIVE float and double

Each numeric wrapper class contains doubleValue(), floatValue(), intValue(), longValue(), and shortValue()
    - returns double, float, int, long, or short

    Syntax:

    new Double(12.4).intValue() // returns 12
    new Integer(12).doubleValue() // returns 12.0

Numeric wrapper class also contains compareTo method which returns 1, 0, or -1
Based off if the number is greater than, equal to, or less than the other number

e.g.
new Double(12.4).compareTo(new Double(12.3)); // returns 1


static valueOf methods
    - this method creates a new object initialized to the value represented by the specified string

    e.g.
    Double doubleObject = Double.valueOf(12.4);

static parsing methods
    - Each numeric wrapper class hass two overloaded parsing methods to parse a numeric string
      into an appropriate numeric value based on 10 or any radix (2 for binary, 8 for octal, 16 for hexadecimal)

    e.g.
    public static parseInt (String s)
    public static int parseInt (String s, int radix)

    Integer.parseInt("11, 2"); // returns 3 because of binary

    ** You can also convert a decimal number into hex number using format method

    e.g.

    String.format("%x", 26); // returns 1A

10.8: Automatic Conversion Between Primitive Types and Wrapper Class Types

- converting a primitive value to a wrapper object is called boxing
- the reverse process is called unboxing

e.g.:
    Integer intObject = new Integer(2); (is equal to)
    Integer intObject = 2;

    **this is due to autoboxing**

    int i = 1; (is equal to)
    Integer i = new Integer(1);

    **this is due to autounboxing


10.9: The BigInteger and BigDecimal Classes

- can be used to represent integers or decimal numbers of any size and precision
**contained in the java.math package is immutable

- BigInteger can represent an integer of any size
- Also can create instances of these both using BigInteger(String) or BigDecimal(String)

- used with the methods of add, subtract, multiply, divide, and remainder

- divide method may throw ArithmeticException if result cannot be terminated
** use overloaded **
    divide(BigDecimal d, int scale, int roundingMode)

    e.g.:
    divide(b, 20, BigDecimal.ROUND_UP)

Relevant code:
LargeFactorial.java

10.10: The String Class

- String objects are immutable, it cannot be changed once it is created
    methods:
        - charAt(index)
        - length()
        - substring
        - indexOf
        - lastIndexOf
        - equals
        - compareTo
        - trim()
        - toLowerCase()
        - toUpperCase()

10.10.1 - Constructing a String

syntax:
    String newString = new String(stringLiteral);

**You can also create a string from array of characters**

e.g.
    char[] charArray = {'G', 'o', 'o', 'd', ' ', 'D', 'a', 'y'};
    String message = new String(charArray);

10.10.2 - Immutable Strings and Interned Strings

- because strings are immutable, JVM uses unique instance of string literals to improve efficiency and save memory (interned string)
- therefore, even if two string objects have same contents, they are not necessarily equal

e.g.
    String s1 = "Welcome to Java";
    String s2 = new String("Welcome to Java");
    String s3 = "Welcome to Java";

    s1 != s2
    but,
    s1 == s3

10.10.3 - Replacing and Splitting Strings
    Methods:
    - replace
        syntax:
        "Welcome".replace("e", "AB") returns a new string, WABlcomAB.

    - replaceFirst
        syntax:
        "Welcome".replaceFirst("e", "AB") returns a new string, WABlcome.

    - replaceAll
        syntax:
        String s = "a+b$#c".replaceAll("[$+#]", "NNN");
        System.out.println(s);

        regex[$+#] specifies chars to replace: $, +, and #
        thus this prints out aNNNbNNNNNNc

    ** these all return a new string derived from original string without altering the og string

    - split
    ** used to extract tokens from string with specified delimiter(s)
        syntax:
        String[] tokens = "Java#HTML#Perl".split("#");

        for (int i = 0; i < tokens.length; i++)
            System.out.print(tokens[i] + " ");

        displays Java HTML Perl

10.10.4 - Matching, Replacing, and Splitting by Patterns

- often there will be a need to write code that validates user input
    ** a regular expression, or REGEX is a string that describes a pattern for matching a set of strings

    Method(s):
    - matches
    ** matches fixed strings and set of strings that follow a pattern

        syntax:
        "Java".equals("Java");

        "Java is powerful".matches("Java.*")

        ** Java.* is a regex which describes a string pattern that begins with Java followed by any zero of more characters
        or

        "440–02–4534".matches("\\d{3}–\\d{2}–\\d{4}")

        ** \\d represents a single digit, \\d{#} represents # digits
        or

        String[] tokens = "Java,C?C#,C++".split("[.,:;?]");

        for (int i = 0; i < tokens.length; i++)
            System.out.println(tokens[i]);

        ** this [.,:;?] specifies a pattern that matches any of the char inside the square brackets, and thus splits the string

10.10.5 - Conversion between Strings and Arrays

- strings can be converted into an array and vice versa

- for strings to array of char, use toCharArray method

    syntax:
    char[] chars = "Java".toCharArray();

    char[0] is J
    char[1] is a
    char[2] is v
    char[3] is a

- can also use getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
    ** to copy substring of string from index srcBegin to index srcEnd-1 into array dst starting from index dstBegin

10.10.6 - Converting Characters and Numeric Values to Strings

- convert numbers into strings using overloaded static valueOf method

    syntax:
    String.valueOf(data);

10.10.7 - Formatting Strings

- String class contains format method to return formatted string

    syntax:
    String.format(format, item1, item2, ..., itemn);

10.11: The StringBuilder and StringBuffer Classes

- these are mutable and can be used where a string is used
- can add, insert, or append new contents into their objects

- methods for modifying the buffer in StringBuffer are synchronized
    ** only one task allowed to execute the methods

- use StringBuffer if class might be accessed by multiple taks (concurrent programming)

- use StringBuilder if class is accessed by single task (no synchronization)
    ** Has three constructors and more than 30 methods to manage the builder and modify the strings in the builder

    syntax:
    StringBuilder(); // empty string builder constructed with capacity of 16

    StringBuilder(capacity: int); // string builder constructed with capacity of specified int

    StringBuilder(s: String);   // string builder constructed with specified string

10.11.1 - Modifying Strings in the StringBuilder

- there are many methods in the stringbuilder class to append, insert, delete, and replace a specified position in string builder

    Method(s)
    +append(data: char[]): StringBuilder    // appends a char array into string builder

    +append(data: char[], oset: int, len: int):
    StringBuilder                           // appends a subarray in data into this string builder

    +append(v: aPrimitiveType): StringBuilder   // appends a primitive-type value as a string to this builder

    +append(s: String): StringBuilder           // appends a string to this string builder

    +delete(startIndex: int, endIndex: int):
    StringBuilder                               // Deletes characters from startIndex to endIndex-1

    +deleteCharAt(index: int): StringBuilder    // deletes a character at a specified index

    +insert(index: int, data: char[], oset: int,
    len: int): StringBuilder                    // inserts a subarray of the data in the array into the builder at the specified index

    +insert(oset: int, data: char[]):
    StringBuilder                               // Inserts data into this builder at the position offset.

    +insert(oset: int, b: aPrimitiveType):
    StringBuilder                               // Inserts a value converted to a string into this builder.

    +insert(oset: int, s: String): StringBuilder   // Inserts a string into this builder at the position offset

    +replace(startIndex: int, endIndex: int, s:
    String): StringBuilder                      // Replaces the characters in this builder from startIndex
                                                   to endIndex – 1 with the specied string

    +reverse(): StringBuilder                   // Reverses the characters in the builder

    +setCharAt(index: int, ch: char): void      // Sets a new character at the specied index in this
                                                   builder

    ** if a string does not need to be changed, use String not StringBuilder **

10.11.2 - The toString, capacity, length, setLength, and charAt Methods

- There are also methods to manipulate string builders and obtain their properties

    Method(s)
    +toString(): String // Returns a string object from the string builder.

    +capacity(): int    // Returns the capacity of this string builder.

    +charAt(index: int): char   // Returns the character at the specied index.

    +length(): int  // Returns the number of characters in this builder.

    +setLength(newLength: int): void    // Sets a new length in this builder.

    +substring(startIndex: int): String // Returns a substring starting at startIndex.

    +substring(startIndex: int, endIndex: int): // Returns a substring from startIndex to endIndex – 1.
        String

    +trimToSize(): void // Reduces the storage size used for the string builder.

10.11.3 - Case Study: Ignoring Nonalphanumeric Characters When Checking Palindromes

Relevant code:
PalindromeIgnoreNonAlphanumeric.java

-------------------------------------------------------------------------------------------------------
// **add ch 11 here

Chapter 12) Exception Handling and Text I/O

12.1: Introduction

- Exceptions are runtime errors
- Exception handling enables a program to deal with runtime errors and continue its normal execution
    e.g.
    https://www.geeksforgeeks.org/types-of-exception-in-java-with-examples/     // these are built in exceptions (There is a hierarchy of exceptions / NOT A LIST // class notes & slides)
    - ArrayIndexOutOfBounds
    - InputMismatchException, etc.


12.2: Exception-handling Overview

- program method should never terminate the program, should be up to user
- Java enables a method to throw an exception that be caught and handled by the caller

    syntax:
    public ...
        if (conditional)
            throw new EXCEPTION("output to caller") // exception is an object thrown (specified exeception is dataType in java API)

    public static void main(String [] args) {

        stmnts...;

        try {
            stmnts / methods...
        } catch (EXCEPTION catchBlockParameter) {   // catch-block header // catch-block param is usually ex
            code to process exception...
            // usually a print statement
        }

        stmnts...
    }

- the execution of a throw stmnt is called throwing an exception
    ** exception is an object created from an exception class
- when an exception is thrown, normal execution is interrupted
- "throw an exception" passes an exception from one place to another
    ** the stmnt to invoke the method is in a "try" block

- the try block contains code that is executed in normal circumstances

- the exception is caught by the catch block

- the catch block is executed to handle the exception

** advanage of using exception handling
    - it enables a method to throw an exception to its caller, enabling the caller to handle the exception

- often, methods called do not know what to do in case of an error
    **this is typically the case for library methods
    ** key benefit is separating the detection of error (in called method) from the handling of error (in calling method)

**runtime exceptions don't have to be declared, thus every other exception must be included after the called method param as well as in method body in the called method**

Relevant code:
Quotient.java
QuotientWithIf.java
QuotientWithMethod.java
QuotientWithException.java

12.3: Exception Types

- the root class for exceptions is java.lang.Throwable

** The class names Error, Exception, and RuntimeException are all exceptions and all of the errors occur at runtime

- you can create own exception classes by extending Eception or a subclass of Exception

- exception classes can be classified into 3 major types:
    1. System errors - thrown by JVM and are represented in the Error class
        ** Error class describes internal system errors
    
    2. Exceptions - represented by Exception class, which describes errors caused by your program and by external circumstances
        ** these errors can be caught and handled by your program

    3. Runtime Exceptions - represented in RuntimeException class - which describes programming errors

** if its possible to rethrow an exception, it throws it to antoher method **
    e.g.

    for example, if the exception is in method1 and another method, method2 calls it and it throws exception right after its param, and if said method2 is called in another method, the exception travels up the stack
        ** must have checked exceptions (the middle method(s) throws exception)

        **All other exceptions other than runtime and errors are checked exceptions, needing try and catch blocks

    stack diagram is a very good way to trace exception rethrows** also in main, the "throw exception" is optional

    runtime exceptions don't have to be declared as usual
        ** runtime exceptions are unchecked exceptions (their subclasses too)

    errors are like runtime exceptions because they are unchecked (their subclasses too)


12.4: More on Exception Handling

- A handler for exception is found through chain of reverse method calls, starting from current method

12.4.1 - Declaring Exceptions

- Often, to declare an exception in a method, you do it in the method header using: throws EXCEPTION after the method params
    ** if there are multiple exceptions to be thrown, go to the next line and do: throws EXCEPTION1, EXCEPTION2, ..., etc. (the exceptions are separated by commas)

12.4.2 - Throwing Exceptions

- program that detects an error which creates an instance of the appropriate exception type

12.4.3 - Catching Exceptions

12.4.4 - Getting Information from Exceptions

- exception object has valuable info about exception

    Method(s)

    from java.lang.Throwable, you can get info regarding the exception using these methods:

    +getMessage(): String   // Returns the message that describes this exception object.

    +toString(): String // Returns the concatenation of three strings: (1) the full name of the exception
                           class; (2) ":" (a colon and a space); and (3) the getMessage() method

    +printStackTrace(): void    // Prints the Throwable object and its call stack trace information on the
                                       console.

    +getStackTrace():
    StackTraceElement[] // Returns an array of stack trace elements representing the stack trace
                               pertaining to this exception object.

Relevant code:

TestException.java

12.4.5 - Example: Declaring, Throwing, and Catching Exceptions

Relevant code:

CircleWithException.java
TestCircleWithException.java


12.5: The finally Clause

12.6: When to Use Exceptions

12.7: Rethrowing Exceptions

12.8: Chained Exceptions

Relevant code:
ChainedExceptionDemo.java

12.9: Defining Custom Exception Classes

Relevant code:
InvalidRadiusException.java
TestCircleWithCustomException.java

12.10: The File Class

    Method(s):


Relevant code:
TestFileClass.java

12.11: File Input and Output

12.11.1 - Writing Data Using PrintWriter

    Method(s):

Relevant code:
WriteData.java

12.11.2 - Closing Resources Automatically Using try-with-resources

Relevant code:
WriteDataWithAutoClose.java

12.11.3 - Reading Data Using Scanner

    Method(s):


Relevant code:
ReadData.java

12.11.4 - How Does Scanner Work?

12.11.5 - Case Study: Replacing Text

Relevant code:
ReplaceText.java

12.12: Reading Data from the Web

Relevant code:
readFileFromURL.java

12.13: Case Study: Web Crawler

Relevant code:
WebCrawler.java

3 Pillars of OOP (Object Oriented Programming)

1. Data hiding in ENCAPSULATION

2. Inheritance -  your class and other class, your class gets something from the other class (child class gets from the parent class etc.)
    ** Each class has exactly one parent, something exclusive to JAVA
    ** this is a "IS A" relationship unike composition & aggregation, which are "HAS A" relationships

3. Polymorphism












Relevant code:

12.5 - InputMismatchExceptionDemo.java

// must do ch12 reading n stuff 10/28 ** ASSIGNMENTS DUE 11/2 and 11/4 DO ASAP

    


// **add chapter 13 here
 */
